{"version":3,"sources":["../fable_domainModel.fsx"],"names":[],"mappings":"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","file":"fable_domainModel.js","sourcesContent":["open System\n\ntype TrackingJob = {\n    identifier : string;    \n    mutable subscription : obj option;\n    latitude : double;\n    longitude : double;\n    utcTimestamp : DateTime;             \n}\n\ntype ILocationQuery =\n    abstract member Subscribe: TrackingJob -> (string -> double -> double -> DateTime -> unit) -> unit\n    abstract member UnSubscribe : TrackingJob -> unit\n\ntype Track = {\n    mintimestamp : DateTime;\n    maxtimestamp : DateTime;\n    name : string;\n}\n\ntype TrackingPoint = {\n   latitude : double;\n   longitude : double;\n   timestamputc : DateTime;\n   speed : double;\n   distanceCovered : double;\n   distance : double;\n   index : int;\n   elevation : double;      \n}\n\ntype ElevationPoint = {\n    index : int\n    elevation : double\n}\n\nlet toRad x =\n    x * Math.PI / 180.0\n\nlet distance lat1 lon1 lat2 lon2 =\n    let R = 6371.0 // Radius of the earth in km\n    let dLat = toRad(lat2 - lat1)  // Javascript functions in radians\n    let dLon = toRad(lon2 - lon1)\n    let a = Math.Sin(dLat / 2.0) * Math.Sin(dLat / 2.0) +\n            Math.Cos(toRad(lat1)) * Math.Cos(toRad(lat2)) *\n            Math.Sin(dLon / 2.0) * Math.Sin(dLon / 2.0)\n    let c = 2.0 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1.0 - a))\n    let d = R * c // Distance in km\n    d * 1000.0\n\n\ntype TrackVisualization(name : string, points : TrackingPoint List) =         \n    member val ElevationPoints : ElevationPoint[] = Array.empty with get, set\n    member this.Points = points     \n    member this.TrackName = name \n    member val LastKnownPosition : TrackingPoint option = None with get, set\n\n    \n\n    member this.updateTrackMarker point = \n        this.LastKnownPosition <- Some point\n\n    member this.totalDistanceInMeters () = \n        this.Points.[this.Points.Length - 1].distanceCovered;\n\n    member this.AssignElevationPoints elevationPoints = \n        this.ElevationPoints <- elevationPoints        \n\n    member this.getIndexOfNearestPoint (distanceInMeters) =   \n        match this.Points |> List.tryFindIndex (fun (p) -> p.distanceCovered >= distanceInMeters) with\n            | Some index -> index\n            | None -> this.Points.Length - 1\n\n    member this.getGeoPointFromElevationDataIndex (index : int, totalElevationPoints) =\n        let meters = (double index / double totalElevationPoints) * this.totalDistanceInMeters();\n        let markerPointIndex = this.getIndexOfNearestPoint(meters);\n        let geoPoint = this.getPointAt(markerPointIndex);\n        geoPoint;\n  \n\n    member this.getPointAt index =\n        this.Points.[index]    \n\n    static member  calculate points =\n        let mutable totalDistance = 0.0        \n        points\n        |> List.mapi (fun i p ->\n                        match i with\n                        | 0 -> {p with speed = 0.0; distanceCovered = 0.0; }\n                        | _ ->  \n                            let distanceBetween = distance points.[i - 1].latitude points.[i - 1].longitude p.latitude p.longitude\n                            let timespan = p.timestamputc - points.[i - 1].timestamputc\n                            let speed = if timespan > TimeSpan.Zero then\n                                            distanceBetween / (timespan.TotalMilliseconds / 1000.0)\n                                        else \n                                            0.0\n                            totalDistance <- totalDistance + distanceBetween                         \n                            {p with\n                                speed = speed\n                                distance = distanceBetween\n                                distanceCovered = totalDistance                                \n                            }\n                       )                             \n     \n\n\ntype TrackingService(locationQuery : ILocationQuery, onPositionChanged) = \n    member this.LocationQuery : ILocationQuery = locationQuery\n    member this.OnPositionChanged : string -> double -> double -> DateTime -> unit = onPositionChanged\n\n    member val ownTrackingJob = {            \n            identifier = String.Empty;            \n            subscription = None;\n            latitude = 0.0;\n            longitude = 0.0;\n            utcTimestamp = DateTime.UtcNow;                \n            }\n    member val observedTrackingJobs : TrackingJob List = List.Empty with get, set    \n    \n    member this.CreateTrackingJob name latitude longitude =\n        {            \n            identifier = name;            \n            subscription = None;\n            latitude = latitude;\n            longitude = longitude;\n            utcTimestamp = DateTime.UtcNow;            \n        }\n    \n    member this.Track identifier =                                    \n        let job = if not(this.ContainsTrackingJob(identifier)) then \n                    let newJob = this.CreateTrackingJob identifier 0.0 0.0           \n                    this.observedTrackingJobs <- this.observedTrackingJobs @ [newJob]       \n                    newJob\n                  else\n                    this.observedTrackingJobs.[this.IndexOf identifier]\n        if job.subscription.IsNone then                 \n            this.LocationQuery.Subscribe job (fun identifier latitude longitude timestamputc ->\n                                                     this.UpdateCoordinates identifier latitude longitude timestamputc\n                                                     this.OnPositionChanged identifier latitude longitude timestamputc\n                                                     )\n\n    member this.UpdateCoordinates name latitude longitude timestamputc =     \n        this.observedTrackingJobs <- this.observedTrackingJobs |> List.map (fun i -> \n                                                                    if i.identifier = name then \n                                                                        {i with \n                                                                            latitude = latitude\n                                                                            longitude = longitude\n                                                                            utcTimestamp = timestamputc}\n                                                                    else i)                                                                      \n        ignore()\n\n    member this.IndexOf name = \n        List.findIndex (fun j -> j.identifier = name) this.observedTrackingJobs\n\n    member this.ReleaseTrack identifier =\n        let job = this.observedTrackingJobs.[this.IndexOf identifier]\n        this.LocationQuery.UnSubscribe(job)\n        job.subscription <- None\n\n    member this.DeleteTrackingJob(job) =\n        this.LocationQuery.UnSubscribe(job)\n        this.observedTrackingJobs <- List.where (fun j -> j <> job) this.observedTrackingJobs    \n    \n    member this.ContainsTrackingJob(name) =\n        List.exists (fun j -> j.identifier = name) this.observedTrackingJobs\n\n\n\ntype LocationTracker = {\n    TrackingService : TrackingService\n    Visualization : TrackVisualization\n    Tracks : Track List\n    Error : string option\n    Info : string option\n}\n    \n    \n"]}