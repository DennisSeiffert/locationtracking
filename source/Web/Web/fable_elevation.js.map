{"version":3,"sources":["../fable_elevation.fsx"],"names":[],"mappings":"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","file":"fable_elevation.js","sourcesContent":["#r \"node_modules/fable-core/Fable.Core.dll\"\n#r \"node_modules/fable-react/Fable.React.dll\"\n#r \"node_modules/fable-powerpack/Fable.PowerPack.dll\"\n#r \"node_modules/fable-redux/Fable.Redux.dll\"\n#r \"node_modules/fable-reactredux/Fable.ReactRedux.dll\"\n#r \"node_modules/fable-reduxthunk/Fable.ReduxThunk.dll\"\n#load \"node_modules/fable-import-d3/Fable.Import.D3.fs\"\n#load \"fable_domainModel.fsx\"\n#load \"fable_backend.fsx\"\nopen Fable.Core\nopen Fable.React\nopen Fable.Import\nopen Fable.PowerPack\nopen System\nopen Fable_domainModel\nopen Backend\nopen Fable.Core.JsInterop\nopen Fable.Helpers.ReactRedux\nopen Fable.Helpers.ReduxThunk\n\nmodule R = Fable.Helpers.React\nopen R.Props\n\ntype [<Pojo>] ElevationProps = {    \n    CurrentTrack : TrackVisualization\n    OnShowElevationMarker : TrackingPoint -> unit    \n}\n\ntype Margin = { \n        top: float\n        right: float\n        left: float\n        bottom: float \n    }\n\ntype ChartDimension = {\n          margin : Margin\n          svgWidth : float\n          svgHeight : float\n          leftAxisSpace : float\n          chartWidth : float\n          chartHeight : float\n          xAxisWidth : float\n        }\n\ntype [<Pojo>] ElevationViewState = {\n    x : D3.Scale.Linear<float,float>\n    y : D3.Scale.Linear<float,float>\n    ySpeed : D3.Scale.Linear<float,float>\n    touchScale : D3.Scale.Linear<float,float>\n    xAxis : D3.Svg.Axis    \n    yAxis : D3.Svg.Axis\n    ySpeedAxis : D3.Svg.Axis\n    svg : D3.Selection<obj>\n    chartWrapper :  D3.Selection<obj>    \n    speedMarker : D3.Selection<obj>\n    elevationMarker : D3.Selection<obj>    \n}\n\n\n[<Emit(\"d3.select(this).attr('fill', '').classed('active', $0)\")>]\nlet markElevationBarAsSelected(selected: bool) : unit = jsNative    \n\ntype ElevationChart(props) = \n    inherit React.Component<ElevationProps, ElevationViewState>(props)\n\n\n    member this.shouldComponentUpdate nextprops nextState = \n        nextprops.CurrentTrack.ElevationPoints.Length > 0\n    member this.componentDidMount (_) =\n        this.initializeChart() \n\n    member this.componentDidUpdate prevProps prevState =                 \n        this.renderChart()\n\n    member this.onMouseOverHandler(index) =\n        let geoPoint = this.props.CurrentTrack.getGeoPointFromElevationDataIndex(index, this.props.CurrentTrack.ElevationPoints.Length) \n        this.props.OnShowElevationMarker geoPoint\n        ignore()\n        // if this.props.CurrentTrack.hasElevationMarker() then \n        //     showPosition(geoPoint.latitude, geoPoint.longitude, this.currentTrack.elevationMarker);\n  \n  \n\n    member this.onTouchMove (e : Browser.Event) =\n        let xy = D3.Globals.touches(e.target).[0]\n        let xPos = fst(xy)\n        let yPos = snd(xy)\n        let dimensions = this.updateDimensions(Browser.window.innerWidth)\n\n        this.state.speedMarker\n          .attr(\"x1\", 0)\n          .attr(\"y1\", yPos)\n          .attr(\"x2\", dimensions.xAxisWidth)\n          .attr(\"y2\", yPos)\n          .classed(\"visible\", true)\n        |> ignore\n\n        let xPosWithinGraph = Math.Max(Math.Min(xPos, dimensions.xAxisWidth), dimensions.leftAxisSpace)\n        this.state.elevationMarker\n          .attr(\"x1\", xPosWithinGraph)\n          .attr(\"y1\", 0)\n          .attr(\"x2\", xPosWithinGraph)\n          .attr(\"y2\", dimensions.chartHeight)\n          .classed(\"visible\", true)\n        |> ignore\n  \n\n    member  this.getGeoPointFromElevationDataIndex(index) =   \n        let meters = double index / double this.props.CurrentTrack.Points.Length * this.props.CurrentTrack.totalDistanceInMeters()\n        let markerPointIndex = this.props.CurrentTrack.getIndexOfNearestPoint(meters)\n        let geoPoint = this.props.CurrentTrack.getPointAt(markerPointIndex)\n        geoPoint\n  \n\n    member this.toKm(meters : double) = meters / 1000.0    \n\n\n\n    member this.addAxes(state, xAxisWidth : float, chartHeight : float) = \n        let axes = state.chartWrapper.append(\"g\")\n\n        axes.append(\"g\")\n          .attr(\"class\", box \"x axis\")\n          .attr(\"transform\", String.Format(@\"translate(0, {0})\",  chartHeight.ToString()))\n          .call(state.xAxis) |> ignore\n\n        axes.append(\"g\")\n          .attr(\"class\", box \"y axis\")\n          .call(state.yAxis)\n          .append(\"text\")\n          //.attr(\"transform\", box \"rotate(-90)\")\n          .attr(\"y\", -10)\n          .attr(\"x\", 60)\n          //.attr(\"dy\", box \".71em\")\n          .style(\"text-anchor\", D3.Primitive.Case2 \"end\")\n          .text(\"Elevation (m)\") |> ignore\n\n        axes.append(\"g\")\n          .attr(\"class\",D3.Primitive.Case2 \"ySpeed axis\")\n          .attr(\"transform\", String.Format(\"translate({0}, 0)\", xAxisWidth))\n          .call(state.ySpeedAxis)\n          .append(\"text\")\n          //.attr(\"transform\", \"rotate(-90)\")\n          .attr(\"y\", -10)\n          .attr(\"x\", 30)\n          .style(\"text-anchor\", \"end\")\n          .text(\"Speed (km/h)\")          \n\n    member this.drawPaths (state, dimensions) =        \n        //update x and y scales to new dimensions\n        //self.xSpeed.range([0, dimensions.xAxisWidth]);\n        state.x.range([|0.0; dimensions.xAxisWidth|]) |> ignore\n        state.y.range([|dimensions.chartHeight; 0.0|]) |> ignore\n        state.ySpeed.range([|dimensions.chartHeight; 0.0|]) |> ignore\n\n        let maxXValue = this.toKm(this.props.CurrentTrack.totalDistanceInMeters())  \n        let totalElevationPoints = this.props.CurrentTrack.ElevationPoints.Length                          \n        state.x.domain([|0.0; maxXValue |]) |> ignore \n        state.y.domain([|0.0; this.props.CurrentTrack.ElevationPoints |> Array.map (fun (d) -> d.elevation) |> Array.max |]) |> ignore\n        state.ySpeed.domain([|0.0; this.props.CurrentTrack.Points |> List.map (fun (d) -> d.speed * 3.6) |> List.max |]) |> ignore\n        let bars = state.chartWrapper.selectAll(\".elevationbar\").data(this.props.CurrentTrack.ElevationPoints)\n        bars?attr(\"x\",Func<_,_,_,_>(fun data _ _ ->\n                                                  state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index, totalElevationPoints).distanceCovered))\n                                    ))\n                                    ?attr(\"y\",Func<_,_,_,_>( fun data _ _ -> state.y.Invoke(data.elevation)))\n                                    ?attr(\"width\",Func<_,_,_,_>( fun data _ _ ->\n                                                      let widthInPixel = Math.Min(state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index + 1, totalElevationPoints).distanceCovered)), state.x.range().[1]) -\n                                                                            state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index, totalElevationPoints).distanceCovered))\n                                                      widthInPixel\n                                    ))                                                                    \n                                    ?attr(\"height\",Func<_,_,_,_>( fun data i j -> dimensions.chartHeight - state.y.Invoke(data.elevation))) |> ignore\n        bars?enter()\n            ?append(\"rect\")                        \n                                    ?attr(\"class\", \"elevationbar\")\n                                    ?attr(\"x\",Func<_,_,_,_>(fun data _ _ ->\n                                                  state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index, totalElevationPoints).distanceCovered))\n                                    ))\n                                    ?attr(\"y\",Func<_,_,_,_>( fun data _ _ -> state.y.Invoke(data.elevation)))\n                                    ?attr(\"width\",Func<_,_,_,_>( fun data _ _ ->\n                                                      Math.Min(state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index + 1, totalElevationPoints).distanceCovered)), state.x.range().[1]) -\n                                                      state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index,totalElevationPoints).distanceCovered))\n                                    ))                                                                    \n                                    ?attr(\"height\",Func<_,_,_,_>( fun data i j -> dimensions.chartHeight - state.y.Invoke(data.elevation)))\n                                    ?on(\"mouseover\", fun data i j ->\n                                                                    this.onMouseOverHandler(data.index) \n                                                                    D3.Globals.select(Browser.event.currentTarget).attr(\"fill\",\"\").classed(\"active\", true)\n                                    )\n                                    ?on(\"mouseout\",fun data _ _ ->                                                                                                                \n                                                        D3.Globals.select(Browser.event.currentTarget).attr(\"fill\",\"\").classed(\"active\", false)\n                                    ) |> ignore\n        bars?exit()?remove() |> ignore\n\n         //update the axis and line\n        //self.xSpeedAxis.scale(self.xSpeed);\n        state.xAxis.scale(state.x)|> ignore\n        state.yAxis.scale(state.y)|> ignore\n        state.ySpeedAxis.scale(state.ySpeed)|> ignore\n\n        let lines = state.chartWrapper.selectAll(\".line\").data([|0|])\n        let line = D3.Svg.Globals.line<TrackingPoint>()\n                        .x(fun d _ -> state.x.Invoke(this.toKm(d.distanceCovered)))\n                        .y(fun d _ -> state.ySpeed.Invoke(d.speed * 3.6))\n                        .interpolate_linear()  \n        lines?attr(\"d\", line.Invoke(Array.ofList this.props.CurrentTrack.Points)) |> ignore\n        lines?enter()?append(\"path\")?classed(\"line\", true)        \n      \n\n    member this.renderChart() =\n        let dimensions = this.updateDimensions(Browser.window.innerWidth);\n\n        this.drawPaths(this.state, dimensions)\n\n        //update svg elements to new dimensions\n        this.state.svg\n          .attr(\"width\", dimensions.svgWidth) \n          .attr(\"height\", dimensions.svgHeight)|> ignore\n        this.state.chartWrapper\n            .attr(\"transform\", \"translate(\" + dimensions.margin.left.ToString() + \",\" + dimensions.margin.top.ToString() + \")\")\n            |> ignore        \n\n        this.state.svg.select(\".x.axis\")\n          .attr(\"transform\", \"translate(0,\" + dimensions.chartHeight.ToString() + \")\")\n          .call(this.state.xAxis)\n          |> ignore\n\n        this.state.svg.select(\".y.axis\")\n          .call(this.state.yAxis)\n          |> ignore\n\n        this.state.svg.select(\".ySpeed.axis\")\n          .attr(\"transform\", \"translate(\" + dimensions.xAxisWidth.ToString() + \", 0)\")\n          .call(this.state.ySpeedAxis)\n          |> ignore\n\n        //this.state.path.attr(\"d\", this.state.line)        \n        \n\n\n    member this.initializeChart() =\n        let dimensions = this.updateDimensions(Browser.window.innerWidth);        \n        let svg = D3.Globals.select(\".elevation_chart\").append(\"svg\")\n                        .attr(\"width\", D3.Primitive.Case1 dimensions.svgWidth)\n                        .attr(\"height\", D3.Primitive.Case1 dimensions.svgHeight)\n        let touchScale = D3.Scale.Globals.linear().domain([|0.0; dimensions.xAxisWidth|]).range([|0.0; (float)this.props.CurrentTrack.Points.Length-1.0|]).clamp(true)\n        let maxXValue = this.toKm(this.props.CurrentTrack.totalDistanceInMeters())                             \n        let x = D3.Scale.Globals.linear()\n                        .range([|0.0; dimensions.xAxisWidth |])\n                        .domain([|0.0; maxXValue |])\n        // this.xSpeed = d3.time.scale().range([0, dimensions.xAxisWidth])\n        //   .domain(d3.extent(this.currentTrack.points, function (d) { return d.timestamp; }));\n        let y = D3.Scale.Globals.linear()\n                        .range([|dimensions.chartHeight; 0.0|])\n                        .domain([|0.0; this.props.CurrentTrack.ElevationPoints |> Array.map (fun (d) -> d.elevation) |> Array.max |])                \n        let ySpeed = D3.Scale.Globals.linear()\n                        .range([|dimensions.chartHeight; 0.0|])\n                        .domain([|0.0; this.props.CurrentTrack.Points |> List.map (fun (d) -> d.speed * 3.6) |> List.max |])\n        let chartWrapper = svg\n                            .append(\"g\")\n                            // (D3.Globals.transform(\"\").translate(dimensions.margin.left, dimensions.margin.top))\n                            .attr(\"transform\",  \"translate(\" + dimensions.margin.left.ToString() + \",\" + dimensions.margin.top.ToString() + \")\")\n                            .on(\"touchmove\", fun data _ _ -> \n                                                    this.onTouchMove Browser.event \n                                                    box 0 )\n\n        Browser.window.addEventListener_resize (fun (e) -> this.renderChart()\n                                                           box 0\n                                               )\n        let state =\n            {        \n                svg = svg\n                touchScale = D3.Scale.Globals.linear().domain([|0.0; dimensions.xAxisWidth|]).range([|0.0; ((float)this.props.CurrentTrack.Points.Length)-1.0|]).clamp(true)\n                x = x\n                // xSpeed = d3.time.scale().range([0, dimensions.xAxisWidth])\n                //     .domain(d3.extent(this.currentTrack.points, function (d) { return d.timestamp; }));\n                y = y\n                ySpeed = ySpeed\n                xAxis = D3.Svg.Globals.axis().scale(x).orient(\"bottom\")\n                            .innerTickSize(-dimensions.chartHeight).outerTickSize(0.0).tickPadding(10.0)\n        // this.xSpeedAxis = d3.svg.axis().scale(this.xSpeed).orient('bottom')\n        //   .innerTickSize(-dimensions.chartHeight).outerTickSize(0).tickPadding(10);\n                yAxis = D3.Svg.Globals.axis().scale(y).orient(\"left\")\n                            .innerTickSize(-dimensions.chartWidth).outerTickSize(0.0).tickPadding(10.0)\n                ySpeedAxis = D3.Svg.Globals.axis().scale(ySpeed).orient(\"right\")\n                                .innerTickSize(-dimensions.chartWidth).outerTickSize(0.0).tickPadding(10.0)                \n                chartWrapper = chartWrapper                \n                speedMarker = chartWrapper.append(\"line\").classed(\"speedmarker\", true)\n                elevationMarker = chartWrapper.append(\"line\").classed(\"elevationmarker\", true)\n        }\n\n        let axes = this.addAxes(state, dimensions.xAxisWidth, dimensions.chartHeight)\n        this.drawPaths(state, dimensions) |> ignore\n\n        this.setState(state) \n\n \n    member this.updateDimensions (winWidth : double) =\n        let dimensions = {\n          margin = { top = 20.0; right = 40.0; left = 40.0; bottom = 40.0 }\n          svgWidth =  winWidth - 40.0\n          svgHeight =  300.0\n          leftAxisSpace = 40.0  \n          chartWidth = 0.0\n          chartHeight = 0.0\n          xAxisWidth = 0.0        \n        }\n        let xAxisWidth = dimensions.svgWidth - dimensions.margin.left - dimensions.margin.right //- dimensions.leftAxisSpace\n        {dimensions with \n                chartWidth = dimensions.svgWidth - dimensions.margin.left - dimensions.margin.right\n                chartHeight = dimensions.svgHeight - dimensions.margin.top - dimensions.margin.bottom\n                xAxisWidth = xAxisWidth}\n\n    member this.render () =                      \n        R.div [ ClassName \"elevation_chart\"] []\n\n\nlet private mapStateToProps (state : LocationTracker) (ownprops : ElevationProps) =\n    { ownprops with\n        CurrentTrack = state.Visualization        \n    }\nlet private mapDispatchToProps (dispatch : ReactRedux.Dispatcher) (ownprops: ElevationProps) =    \n    { ownprops with        \n        OnShowElevationMarker = fun(trackingPoint) -> ignore()\n    }\n\nlet private setDefaultProps (ownprops : ElevationProps) =\n    { ownprops with\n         CurrentTrack = new TrackVisualization(String.Empty, List.Empty)                      \n         OnShowElevationMarker = fun(trackingPoint) -> ignore() }   \n\nlet createElevationViewComponent =\n    createConnector ()\n    |> withStateMapper mapStateToProps\n    |> withDispatchMapper  mapDispatchToProps   \n    |> withProps setDefaultProps\n    |> buildComponent<ElevationChart, _, _, _>"]}