{"version":3,"sources":["../fable_backend.fsx"],"names":[],"mappings":"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","file":"fable_backend.js","sourcesContent":["module Backend\n\n#r \"node_modules/fable-core/Fable.Core.dll\"\n#r \"node_modules/fable-powerpack/Fable.PowerPack.dll\"\n#r \"node_modules/fable-react/Fable.React.dll\"\n#r \"node_modules/fable-redux/Fable.Redux.dll\"\n#r \"node_modules/fable-reactredux/Fable.ReactRedux.dll\"\n#r \"node_modules/fable-reduxthunk/Fable.ReduxThunk.dll\"\n#load \"fable_domainModel.fsx\"\nopen Fable_domainModel\n#load \"fable_Commands.fsx\"\nopen Commands\n\nopen Fable.Core\nopen Fable.Import\nopen Fable.PowerPack\nopen Fable.PowerPack.Fetch\nopen Fable.PowerPack.Fetch.Fetch_types\nopen Fable.Core.JsInterop\nopen System\nopen Fable.PowerPack.Fetch.Fetch_types\n\n\ntype GoogleMapPoint = { Latitude : double; Longitude : double }\n[<Emit(\"new google.maps.LatLng($0, $1)\")>]\nlet LatLng(lat: double) (lng:double): GoogleMapPoint =\n    { Latitude = lat; Longitude = lng }\n\n[<KeyValueList>]\ntype GoogleElevationQueryDto =    \n    | Path of GoogleMapPoint[]\n    | Samples of int\n\ntype  GoogleElevationService = \n    abstract getElevationAlongPath : GoogleElevationQueryDto list * Func<obj[],string,unit> -> unit\n\n[<Emit(\"new google.maps.ElevationService()\")>]\nlet ConcreteGoogleElevationService : GoogleElevationService = failwith \"JS only\"\n\nlet loadElevationData (points : TrackingPoint[]) (dispatch : ReactRedux.Dispatcher) = \n                // Create an ElevationService.\n    //let elevator = ConcreteGoogleElevationService()\n         \n             // Create a PathElevationRequest object using this array.\n             // Ask for 256 samples along that path.\n             // Initiate the path request. \n    \n    let googleMapPoints = Array.map (fun p -> \n                                            let point = LatLng p.latitude p.longitude                                            \n                                            point\n                                        ) points \n    ConcreteGoogleElevationService.getElevationAlongPath ([\n                                                              Path googleMapPoints\n                                                              Samples 256\n                                                          ], \n                                        Func<_,_, _>(fun elevations message -> \n                                                match message with \n                                                    | \"OK\" -> \n                                                        let elevationPoints = elevations |> Array.mapi (fun index ep -> {index = index; elevation = box ep?elevation :?> double}) \n                                                        dispatch (Commands.ReceivedElevationPoints elevationPoints)\n                                                    | _ -> \n                                                        dispatch (Commands.ReceivedElevationPoints [||])\n                                                        dispatch (Commands.ShowError \"Cannot load elevation points.\"))\n        )    \n\n\n\n\n[<Measure>]\ntype ms\n\ntype LoadTrackingPointsDto = {\n    beginDate : DateTime\n    endDate : DateTime\n}\n\n\nlet private jsonHeaders = \n    [ HttpRequestHeaders.Accept \"application/json\"\n      HttpRequestHeaders.ContentType \"application/json\"           \n    ]\n\nlet private dispatchShowError (dispatch : ReactRedux.Dispatcher) (time : int<ms> option) error =\n    Commands.ShowError error |> dispatch\n    time |> Option.iter (fun t -> \n        Browser.window.setTimeout(box (fun () -> Commands.HideError |> dispatch), t) \n        |> ignore\n)\n\nlet getAllTracks (dispatch : ReactRedux.Dispatcher) =\n    promise {\n        Commands.LoadingTracks |> dispatch\n        let! response =\n            fetch\n                (\"/api/tracks\")\n                [ \n                    RequestProperties.Headers jsonHeaders \n                    Method HttpMethod.OPTIONS\n                ]                \n        if response.Ok then\n            let! tracks = response.json<obj array> ()\n            tracks \n            |> Array.map (fun i -> \n                                    let ranges = box i?ranges :?> list<list<obj>>\n                                    ranges |> List.map (fun r -> \n                                            { \n                                            mintimestamp= DateTime.Parse(string r.[0]?date);\n                                            maxtimestamp = DateTime.Parse(string r.[1]?date); \n                                            name = string i?name }))                                             \n            |> List.concat\n            |> Array.ofList\n            |> Commands.ReceivedTracks |> dispatch\n        else\n            dispatchShowError dispatch None \"Could not fetch tracks from server!\"\n    }\n    |> Promise.map ignore\n\nlet loadTrackingPoints (start, ``end``,  trackName) (dispatch : ReactRedux.Dispatcher) =\n    promise {\n        let! response = \n            postRecord (\"/api/tracks/\" + trackName) {beginDate=start;endDate=``end``} [ \n                    RequestProperties.Headers jsonHeaders                                          \n                ]\n        if response.Ok then\n            let! track = response.json<obj> ()                \n            let trackingPoints = (downcast (box track?trackingpoints)) |> Array.map (fun t -> { \n                                                                                                latitude = (box t?latitude) :?> double\n                                                                                                longitude = (box t?longitude) :?> double\n                                                                                                timestamputc = DateTime.Parse(string t?timestamputc?date)\n                                                                                                speed = 0.0\n                                                                                                elevation = 0.0\n                                                                                                distance = 0.0\n                                                                                                distanceCovered = 0.0\n                                                                                                index = 0\n                                                                                            })        \n            dispatch (Commands.ReceivedTrack(trackName, trackingPoints))\n\n            loadElevationData trackingPoints dispatch\n        else\n            dispatchShowError dispatch None \"Could not fetch track from server!\"  \n    } \n    |> Promise.map ignore\n\n\ntype GpxWayPoint = {\n    lat : double\n    lon : double\n    time : DateTime\n}\n\ntype [<Import(\"*\",\"./node_modules/gpx-parse/dist/gpx-parse-browser.js\")>] GpxParse = \n            static member parseGpx(content : string, handler : Func<obj,obj, unit>): unit = jsNative\n\nlet parseTrackingPointsFromGpx (filenames: Browser.File[]) (dispatch : ReactRedux.Dispatcher) = \n    promise {\n        let file = filenames.[0]\n        let fileReader = Browser.FileReader.Create()\n        fileReader.onload <- fun e -> \n                                 GpxParse.parseGpx(string e.target?result, Func<obj,obj,_>(fun error data ->\n                                                let tracks = box data?tracks :?> obj[]\n                                                let segments = box tracks.[0]?segments :?> obj[]\n                                                let trackingPoints = segments.[0] :?> GpxWayPoint[]\n                                                dispatch (Commands.ReceivedTrack (\"imported track\", (Array.mapi (fun i e -> \n                                                                                                                    { latitude = e.lat\n                                                                                                                      longitude = e.lon\n                                                                                                                      timestamputc = e.time\n                                                                                                                      speed = 0.0\n                                                                                                                      distanceCovered = 0.0\n                                                                                                                      distance = 0.0\n                                                                                                                      index = i\n                                                                                                                      elevation = 0.0}) trackingPoints)))))\n                                 box 0                                \n        fileReader.readAsText(file)               \n    }|> Promise.map ignore\n        \n\nlet loadLocalStorage<'T> key =\n        Browser.localStorage.getItem(key) |> unbox\n        |> Option.map (JS.JSON.parse >> unbox<'T>)\nlet saveToLocalStorage key (data: 'T) =\n        Browser.localStorage.setItem(key, JS.JSON.stringify data)\nlet loadLocationTracker key = \n    loadLocalStorage<LocationTracker> key\n\nlet saveLocationTracker locationTracker =     \n       saveToLocalStorage locationTracker.Visualization.TrackName locationTracker\n\n\n[<Emit(\"new Parse.Query('Posts')\")>]\nlet createParseQuery() = jsNative\n\ntype [<Import(\"*\",\"./parse-latest.js\")>] Parse =\n             static member initialize(appId : string, value : string): unit = jsNative\n             static member serverURL with get(): string = jsNative and set(v: string): unit = jsNative\n\ntype LocationService(host) =\n    do Parse.initialize(\"myAppId\", \"unused\")\n    do Parse.serverURL <- host+\"/parse\"\n    \n    interface ILocationQuery with \n        member this.Subscribe job onShowPosition = \n            let parseQuery = createParseQuery()\n            parseQuery?equalTo(\"name\", job.identifier) |> ignore\n            job.subscription <- parseQuery?subscribe()\n            job.subscription?on(\"create\", fun position ->\n                let name = string (position?get(\"name\"))\n                let latitude = (position?get(\"latitude\")) :?> double\n                let longitude = (position?get(\"longitude\")) :?> double\n                let timestamp = DateTime.Parse (string (position?get(\"timestamputc\")))\n                onShowPosition name latitude longitude timestamp) |> ignore\n            \n            ignore()\n            // if (observedTrackingJob.updatePositionOnMap()) then                \n                //showPosition(position.get(\"latitude\"), position.get(\"longitude\"), observedTrackingJob.marker)            \n\n        member this.UnSubscribe job =             \n            if not(isNull job.subscription) then\n                job.subscription?unsubscribe() |> ignore\n            ignore()  "]}