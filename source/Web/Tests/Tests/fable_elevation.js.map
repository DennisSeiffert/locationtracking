{"version":3,"sources":["../fable_elevation.fsx"],"names":[],"mappings":"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","file":"fable_elevation.js","sourcesContent":["#r \"node_modules/fable-core/Fable.Core.dll\"\n#r \"node_modules/fable-react/Fable.React.dll\"\n#r \"node_modules/fable-powerpack/Fable.PowerPack.dll\"\n#r \"node_modules/fable-redux/Fable.Redux.dll\"\n#r \"node_modules/fable-reactredux/Fable.ReactRedux.dll\"\n#r \"node_modules/fable-reduxthunk/Fable.ReduxThunk.dll\"\n#load \"node_modules/fable-import-d3/Fable.Import.D3.fs\"\n#load \"fable_domainModel.fsx\"\nopen Fable.Core\nopen Fable.React\nopen Fable.Import\nopen Fable.PowerPack\nopen System\nopen Fable_domainModel\nopen Fable.Core.JsInterop\nopen Fable.Helpers.ReactRedux\n\nmodule R = Fable.Helpers.React\nopen R.Props\n\ntype [<Pojo>] ElevationProps = {    \n    CurrentTrack : TrackVisualization\n}\n\ntype Margin = { \n        top: float\n        right: float\n        left: float\n        bottom: float \n    }\n\ntype ChartDimension = {\n          margin : Margin\n          svgWidth : float\n          svgHeight : float\n          leftAxisSpace : float\n          chartWidth : float\n          chartHeight : float\n          xAxisWidth : float\n        }\n\ntype [<Pojo>] ElevationViewState = {\n    x : D3.Scale.Linear<float,float>\n    y : D3.Scale.Linear<float,float>\n    ySpeed : D3.Scale.Linear<float,float>\n    touchScale : D3.Scale.Linear<float,float>\n    xAxis : D3.Svg.Axis\n    yAxis : D3.Svg.Axis\n    ySpeedAxis : D3.Svg.Axis\n    svg : D3.Selection<obj>\n    chartWrapper :  D3.Selection<obj>    \n    speedMarker : D3.Selection<obj>\n    elevationMarker : D3.Selection<obj>    \n}\n\n\n\ntype ElevationChart(props) = \n    inherit React.Component<ElevationProps, ElevationViewState>(props)\n\n\n    member this.componentDidMount (_) =\n        this.initializeChart()        \n    member this.onMouseOverHandler(index) =\n        let geoPoint = this.props.CurrentTrack.getGeoPointFromElevationDataIndex index\n        ignore()\n        // if this.props.CurrentTrack.hasElevationMarker() then \n        //     showPosition(geoPoint.latitude, geoPoint.longitude, this.currentTrack.elevationMarker);\n  \n  \n\n    member this.onTouchMove (e : Browser.Event) =\n        let xy = D3.Globals.touches(e.target).[0]\n        let xPos = fst(xy)\n        let yPos = snd(xy)\n        let dimensions = this.updateDimensions(Browser.window.innerWidth)\n\n        this.state.speedMarker\n          .attr(\"x1\", xPos)\n          .attr(\"y1\", yPos)\n          .attr(\"x2\", dimensions.xAxisWidth)\n          .attr(\"y2\", yPos)\n          .classed(\"visible\", true)\n        |> ignore\n\n        this.state.elevationMarker\n          .attr(\"x1\", 0)\n          .attr(\"y1\", yPos)\n          .attr(\"x2\", xPos)\n          .attr(\"y2\", yPos)\n          .classed(\"visible\", true)\n        |> ignore\n  \n\n    member  this.getGeoPointFromElevationDataIndex(index) =   \n        let meters = double index / double this.props.CurrentTrack.Points.Length * this.props.CurrentTrack.totalDistanceInMeters()\n        let markerPointIndex = this.props.CurrentTrack.getIndexOfNearestPoint(meters)\n        let geoPoint = this.props.CurrentTrack.getPointAt(markerPointIndex)\n        geoPoint\n  \n\n    member this.toKm(meters : double) = meters / 1000.0    \n\n\n\n    member this.addAxes(state, xAxisWidth : float, chartHeight : float) = \n        let axes = state.chartWrapper.append(\"g\")\n\n        axes.append(\"g\")\n          .attr(\"class\", box \"x axis\")\n          .attr(\"transform\", String.Format(@\"translate(0, {0})\",  chartHeight.ToString()))\n          .call(state.xAxis) |> ignore\n\n        axes.append(\"g\")\n          .attr(\"class\", box \"y axis\")\n          .call(state.yAxis)\n          .append(\"text\")\n          .attr(\"transform\", box \"rotate(-90)\")\n          .attr(\"y\", 6)\n          .attr(\"dy\", box \".71em\")\n          .style(\"text-anchor\", D3.Primitive.Case2 \"end\")\n          .text(\"Elevation (m)\") |> ignore\n\n        axes.append(\"g\")\n          .attr(\"class\",D3.Primitive.Case2 \"ySpeed axis\")\n          .attr(\"transform\", String.Format(\"translate({0}, 0)\", xAxisWidth))\n          .call(state.ySpeedAxis)\n          .append(\"text\")\n          .attr(\"transform\", \"rotate(-90)\")\n          .attr(\"y\", 70)\n          .style(\"text-anchor\", \"end\")\n          .text(\"Speed (km/h)\")          \n\n    member this.drawPaths (state, chartWidth, chartHeight) =     \n        let bars = state.chartWrapper.selectAll(\".bar\").data(Array.ofList this.props.CurrentTrack.Points)\n                    |> fun d -> (unbox<D3.Selection.Update<TrackingPoint>> d).enter()\n                    |> fun d -> d.append(\"rect\")                        \n                                    .attr(\"class\", \"elevationbar\")\n                                    .attr(\"x\",Func<_,_,_,_>(fun data _ _ ->\n                                                  state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index).distanceCovered))\n                                    ))\n                                    .attr(\"y\",Func<_,_,_,_>( fun data _ _ -> state.y.Invoke(data.elevation)))\n                                    .attr(\"width\",Func<_,_,_,_>( fun data _ _ ->\n                                                      Math.Min(state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index + 1).distanceCovered)), state.x.range().[1]) -\n                                                      state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(data.index).distanceCovered))\n                                    ))                                                                    \n                                    .attr(\"height\",Func<_,_,_,_>( fun data i j -> chartHeight - state.y.Invoke(data.elevation)))\n                                    .on(\"mouseover\", Func<_,_,_,_>( fun data i j ->\n                                                                    this.onMouseOverHandler(data.index) \n                                                                    D3.Globals.select(\"#elevationbar\").attr(\"fill\", \"\").classed(\"active\", true) |> ignore\n                                                                    box 0\n                                    ))\n                                    .on(\"mouseout\",Func<_,_,_,_>( fun data _ _ ->                                                        \n                                                        D3.Globals.select(\"#elevationbar\").attr(\"fill\", \"\").classed(\"active\", false) |> ignore\n                                                        box 0\n                                    ))\n\n        // let path = state.chartWrapper.append(\"path\").datum(this.props.CurrentTrack.Points).classed(\"line\", true);\n        // let line = D3.Svg.Globals.line<TrackingPoint>()\n        //                 .x(fun data _ -> state.x.Invoke(this.toKm(data.distanceCovered)))\n        //                 .y(fun d _ -> state.ySpeed.Invoke(d.speed * 3.6))\n        //                 .interpolate_monotone()                        \n        // path.attr(\"d\", line) |> ignore;\n        ignore()     \n\n    member this.renderChart() =\n        let dimensions = this.updateDimensions(Browser.window.innerWidth);\n\n\n        //update x and y scales to new dimensions\n        //self.xSpeed.range([0, dimensions.xAxisWidth]);\n        this.state.x.range([|0.0; dimensions.xAxisWidth|]) |> ignore\n        this.state.y.range([|dimensions.chartHeight; 0.0|]) |> ignore\n        this.state.ySpeed.range([|dimensions.chartHeight; 0.0|]) |> ignore\n\n        //update svg elements to new dimensions\n        this.state.svg\n          .attr(\"width\", dimensions.svgWidth) \n          .attr(\"height\", dimensions.svgHeight)|> ignore\n        this.state.chartWrapper\n            .attr(\"transform\", fun _ _ _ -> \"translate(\" + dimensions.margin.left.ToString() + \",\" + dimensions.margin.top.ToString() + \")\")\n            |> ignore        \n\n        //update the axis and line\n        //self.xSpeedAxis.scale(self.xSpeed);\n        this.state.xAxis.scale(this.state.x)|> ignore\n        this.state.yAxis.scale(this.state.y)|> ignore\n        this.state.ySpeedAxis.scale(this.state.ySpeed)|> ignore\n\n        this.state.svg.select(\".x.axis\")\n          .attr(\"transform\", fun _ _ _ ->  \"translate(0,\" + dimensions.chartHeight.ToString() + \")\")\n          .call(this.state.xAxis)\n          |> ignore\n\n        this.state.svg.select(\".y.axis\")\n          .call(this.state.yAxis)\n          |> ignore\n\n        this.state.svg.select(\".ySpeed.axis\")\n          .attr(\"transform\", fun _ _ _ -> \"translate(\" + dimensions.xAxisWidth.ToString() + \", 0)\")\n          .call(this.state.ySpeedAxis)\n          |> ignore\n\n        this.state.chartWrapper.selectAll(\".elevationbar\")\n          .attr(\"x\", fun d -> this.state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(d.index).distanceCovered)))\n          .attr(\"width\", fun d ->\n                            Math.Min(this.state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(d.index + 1).distanceCovered)), this.state.x.range().[1]) -\n                            this.state.x.Invoke(this.toKm(this.props.CurrentTrack.getGeoPointFromElevationDataIndex(d.index).distanceCovered))\n          )\n          .attr(\"y\", fun d -> this.state.y.Invoke(d.elevation))\n          .attr(\"height\", fun d i j -> dimensions.chartHeight - this.state.y.Invoke(d.elevation))\n\n        //this.state.path.attr(\"d\", this.state.line)\n\n\n    member this.initializeChart() =\n        let dimensions = this.updateDimensions(Browser.window.innerWidth);        \n        let svg = D3.Globals.select(\".elevation_chart\").append(\"svg\")\n                        .attr(\"width\", D3.Primitive.Case1 dimensions.svgWidth)\n                        .attr(\"height\", D3.Primitive.Case1 dimensions.svgHeight)\n        let touchScale = D3.Scale.Globals.linear().domain([|0.0; dimensions.xAxisWidth|]).range([|0.0; (float)this.props.CurrentTrack.Points.Length-1.0|]).clamp(true)\n        let x = D3.Scale.Globals.linear()\n                        .range([|0.0; dimensions.xAxisWidth |])\n                        .domain([|0.0; this.props.CurrentTrack.Points |> List.map (fun (d) -> this.toKm(this.getGeoPointFromElevationDataIndex(d.index).distanceCovered)) |> List.max |])\n        // this.xSpeed = d3.time.scale().range([0, dimensions.xAxisWidth])\n        //   .domain(d3.extent(this.currentTrack.points, function (d) { return d.timestamp; }));\n        let y = D3.Scale.Globals.linear()\n                        .range([|dimensions.chartHeight; 0.0|])\n                        .domain([|0.0; this.props.CurrentTrack.Points |> List.map (fun (d) -> d.elevation) |> List.max |])                \n        let ySpeed = D3.Scale.Globals.linear()\n                        .range([|dimensions.chartHeight; 0.0|])\n                        .domain([|0.0; this.props.CurrentTrack.Points |> List.map (fun (d) -> d.speed * 3.6) |> List.max |])\n        let chartWrapper = svg\n                            .append(\"g\")\n                            // (D3.Globals.transform(\"\").translate(dimensions.margin.left, dimensions.margin.top))\n                            .attr(\"transform\",  \"translate(\" + dimensions.margin.left.ToString() + \",\" + dimensions.margin.top.ToString() + \")\")\n                            .on(\"touchmove\", fun data _ _ -> \n                                                    this.onTouchMove Browser.event \n                                                    box 0 )\n        let state =\n            {        \n                svg = svg\n                touchScale = D3.Scale.Globals.linear().domain([|0.0; dimensions.xAxisWidth|]).range([|0.0; ((float)this.props.CurrentTrack.Points.Length)-1.0|]).clamp(true)\n                x = x\n        // this.xSpeed = d3.time.scale().range([0, dimensions.xAxisWidth])\n        //   .domain(d3.extent(this.currentTrack.points, function (d) { return d.timestamp; }));\n                y = y\n                ySpeed = ySpeed\n                xAxis = D3.Svg.Globals.axis().scale(x).orient(\"bottom\")\n                            .innerTickSize(-dimensions.chartHeight).outerTickSize(0.0).tickPadding(10.0)\n        // this.xSpeedAxis = d3.svg.axis().scale(this.xSpeed).orient('bottom')\n        //   .innerTickSize(-dimensions.chartHeight).outerTickSize(0).tickPadding(10);\n                yAxis = D3.Svg.Globals.axis().scale(y).orient(\"left\")\n                            .innerTickSize(-dimensions.chartWidth).outerTickSize(0.0).tickPadding(10.0)\n                ySpeedAxis = D3.Svg.Globals.axis().scale(ySpeed).orient(\"right\")\n                                .innerTickSize(-dimensions.chartWidth).outerTickSize(0.0).tickPadding(10.0)                \n                chartWrapper = chartWrapper                \n                speedMarker = chartWrapper.append(\"line\").classed(\"speedmarker\", true)\n                elevationMarker = chartWrapper.append(\"line\").classed(\"elevationmarker\", true)\n        }\n\n        let axes = this.addAxes(state, dimensions.xAxisWidth, dimensions.chartHeight)\n        this.drawPaths(state, dimensions.chartWidth, dimensions.chartHeight) |> ignore\n\n        this.setState(state)\n        // Browser.window.addEventListener(\"resize\",fun () ->\n        //                                              this.renderChart()\n        //                                              EventListenerOrEventListenerObject.Case1)  \n\n \n    member this.updateDimensions (winWidth : double) =\n        let dimensions = {\n          margin = { top = 20.0; right = 40.0; left = 40.0; bottom = 40.0 }\n          svgWidth =  winWidth - 40.0\n          svgHeight =  300.0\n          leftAxisSpace = 40.0  \n          chartWidth = 0.0\n          chartHeight = 0.0\n          xAxisWidth = 0.0        \n        }\n        let xAxisWidth = dimensions.svgWidth - dimensions.margin.left - dimensions.margin.right - dimensions.leftAxisSpace\n        {dimensions with \n                chartWidth = dimensions.svgWidth - dimensions.margin.left - dimensions.margin.right\n                chartHeight = dimensions.svgHeight - dimensions.margin.top - dimensions.margin.bottom\n                xAxisWidth = xAxisWidth}\n\n    member this.render () =                      \n        R.div [ ClassName \"elevation_chart\"] []\n\n\nlet private mapStateToProps (state : LocationTracker) (ownprops : ElevationProps) =\n    { ownprops with\n        CurrentTrack = state.Visualization        \n    }\n// let private mapDispatchToProps (dispatch : ReactRedux.Dispatcher) ownprops =\n//     { ownprops with\n//         onLoadTracks = fun () -> dispatch <| asThunk (Backend.getAllTracks)   \n//         onLoadTrackingPoints = fun(start, ``end``, trackName) -> asThunk (Backend.loadTrackingPoints(start, ``end``, trackName)) |> dispatch\n//     }\n\nlet private setDefaultProps (ownprops : ElevationProps) =\n    { ownprops with\n         CurrentTrack = new TrackVisualization(String.Empty, List.Empty) }   \n\nlet createElevationViewComponent =\n    createConnector ()\n    |> withStateMapper mapStateToProps    \n    |> withProps setDefaultProps\n    |> buildComponent<ElevationChart, _, _, _>"]}