{"version":3,"sources":["../fable_backend.fsx"],"names":[],"mappings":"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","file":"fable_backend.js","sourcesContent":["module Backend\n\n#r \"node_modules/fable-core/Fable.Core.dll\"\n#r \"node_modules/fable-powerpack/Fable.PowerPack.dll\"\n#r \"node_modules/fable-react/Fable.React.dll\"\n#r \"node_modules/fable-redux/Fable.Redux.dll\"\n#r \"node_modules/fable-reactredux/Fable.ReactRedux.dll\"\n#r \"node_modules/fable-reduxthunk/Fable.ReduxThunk.dll\"\n#load \"fable_domainModel.fsx\"\nopen Fable_domainModel\n#load \"fable_Commands.fsx\"\nopen Commands\n\nopen Fable.Core\nopen Fable.Import\nopen Fable.PowerPack\nopen Fable.PowerPack.Fetch\nopen Fable.PowerPack.Fetch.Fetch_types\nopen Fable.Core.JsInterop\nopen System\nopen Fable.PowerPack.Fetch.Fetch_types\n\n\ntype GoogleMapPoint = { Latitude : double; Longitude : double }\n[<Emit(\"new google.maps.LatLng($0, $1)\")>]\nlet LatLng(lat: double) (lng:double): GoogleMapPoint =\n    { Latitude = lat; Longitude = lng }\n\n[<KeyValueList>]\ntype GoogleElevationQueryDto =    \n    | Path of GoogleMapPoint[]\n    | Samples of int\n\ntype  GoogleElevationService = \n    abstract getElevationAlongPath : GoogleElevationQueryDto list * Func<obj[],string,unit> -> unit\n\n[<Emit(\"new google.maps.ElevationService()\")>]\nlet ConcreteGoogleElevationService : GoogleElevationService = failwith \"JS only\"\n\nlet loadElevationData (points : TrackingPoint[]) (dispatch : ReactRedux.Dispatcher) = \n                // Create an ElevationService.\n    //let elevator = ConcreteGoogleElevationService()\n         \n             // Create a PathElevationRequest object using this array.\n             // Ask for 256 samples along that path.\n             // Initiate the path request. \n    \n    let googleMapPoints = Array.map (fun p -> \n                                            let point = LatLng p.latitude p.longitude                                            \n                                            point\n                                        ) points \n    ConcreteGoogleElevationService.getElevationAlongPath ([\n                                                              Path googleMapPoints\n                                                              Samples 256\n                                                          ], \n                                        Func<_,_, _>(fun elevations message -> \n                                                match message with \n                                                    | \"OK\" -> \n                                                        let elevationPoints = elevations |> Array.mapi (fun index ep -> {index = index; elevation = box ep?elevation :?> double}) \n                                                        dispatch (Commands.ReceivedElevationPoints elevationPoints)\n                                                    | _ -> \n                                                        dispatch (Commands.ReceivedElevationPoints [||])\n                                                        dispatch (Commands.ShowError \"Cannot load elevation points.\"))\n        )    \n\n\n\n\n[<Measure>]\ntype ms\n\ntype LoadTrackingPointsDto = {\n    beginDate : DateTime\n    endDate : DateTime\n}\n\n\nlet private jsonHeaders = \n    [ HttpRequestHeaders.Accept \"application/json\"\n      HttpRequestHeaders.ContentType \"application/json\"           \n    ]\n\nlet private dispatchShowError (dispatch : ReactRedux.Dispatcher) (time : int<ms> option) error =\n    Commands.ShowError error |> dispatch\n    time |> Option.iter (fun t -> \n        Browser.window.setTimeout(box (fun () -> Commands.HideError |> dispatch), t) \n        |> ignore\n)\n\nlet getAllTracks (dispatch : ReactRedux.Dispatcher) =\n    promise {\n        Commands.LoadingTracks |> dispatch\n        let! response =\n            fetch\n                (\"/api/tracks\")\n                [ \n                    RequestProperties.Headers jsonHeaders \n                    Method HttpMethod.OPTIONS\n                ]                \n        if response.Ok then\n            let! tracks = response.json<obj array> ()\n            tracks |> Array.map (fun i -> { \n                                            mintimestamp=DateTime.Parse(string i?mintimestamputc?date);\n                                            maxtimestamp = DateTime.Parse(string i?maxtimestamputc?date); \n                                            name = string i?name }) |> Commands.ReceivedTracks |> dispatch\n        else\n            dispatchShowError dispatch None \"Could not fetch tracks from server!\"\n    }\n    |> Promise.map ignore\n\nlet loadTrackingPoints (start, ``end``,  trackName) (dispatch : ReactRedux.Dispatcher) =\n    promise {\n        let! response = \n            postRecord (\"/api/tracks/\" + trackName) {beginDate=start;endDate=``end``} [ \n                    RequestProperties.Headers jsonHeaders                                          \n                ]\n        if response.Ok then\n            let! track = response.json<obj> ()                \n            let trackingPoints = (downcast (box track?trackingpoints)) |> Array.map (fun t -> { \n                                                                                                latitude = (box t?latitude) :?> double\n                                                                                                longitude = (box t?longitude) :?> double\n                                                                                                timestamputc = DateTime.Parse(string t?timestamputc?date)\n                                                                                                speed = 0.0\n                                                                                                elevation = 0.0\n                                                                                                distance = 0.0\n                                                                                                distanceCovered = 0.0\n                                                                                                index = 0\n                                                                                            })        \n            dispatch (Commands.ReceivedTrack(trackName, trackingPoints))\n\n            loadElevationData trackingPoints dispatch\n        else\n            dispatchShowError dispatch None \"Could not fetch track from server!\"  \n    } \n    |> Promise.map ignore\n\n\nlet loadLocalStorage<'T> key =\n        Browser.localStorage.getItem(key) |> unbox\n        |> Option.map (JS.JSON.parse >> unbox<'T>)\nlet saveToLocalStorage key (data: 'T) =\n        Browser.localStorage.setItem(key, JS.JSON.stringify data)\nlet loadLocationTracker key = \n    loadLocalStorage<LocationTracker> key\n\nlet saveLocationTracker locationTracker = \n    saveToLocalStorage locationTracker.Visualization.TrackName locationTracker\n\n\n[<Emit(\"new Parse.Query('Posts')\")>]\nlet createParseQuery() = jsNative\n\ntype [<Import(\"*\",\"./parse-latest.js\")>] Parse =\n             static member initialize(appId : string, value : string): unit = jsNative\n             static member serverURL with get(): string = jsNative and set(v: string): unit = jsNative\n\ntype LocationService() =\n    do Parse.initialize(\"myAppId\", \"unused\")\n    do Parse.serverURL <- \"/parse\"\n    \n    interface ILocationQuery with \n        member this.Subscribe job onShowPosition = \n            let parseQuery = createParseQuery()\n            parseQuery?equalTo(\"name\", job.identifier) |> ignore\n            job.subscription <- parseQuery?subscribe()\n            job.subscription?on(\"create\", fun position ->\n                let name = string (position?get(\"name\"))\n                let latitude = (position?get(\"latitude\")) :?> double\n                let longitude = (position?get(\"longitude\")) :?> double\n                let timestamp = DateTime.Parse (string (position?get(\"timestamputc\")))\n                onShowPosition name latitude longitude timestamp) |> ignore\n            \n            ignore()\n            // if (observedTrackingJob.updatePositionOnMap()) then                \n                //showPosition(position.get(\"latitude\"), position.get(\"longitude\"), observedTrackingJob.marker)            \n\n        member this.UnSubscribe job =             \n            if not(isNull job.subscription) then\n                job.subscription?unsubscribe() |> ignore\n            ignore()  "]}